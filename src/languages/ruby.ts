import { SyntaxNode } from "web-tree-sitter";
import {
  argumentMatcher,
  cascadingMatcher,
  chainedMatcher,
  conditionMatcher,
  createPatternMatchers,
  matcher,
  trailingMatcher,
  typeMatcher,
} from "../util/nodeMatchers";
import { NodeMatcherAlternative, ScopeType } from "../typings/Types";
import { nodeFinder, typedNodeFinder } from "../util/nodeFinders";
import { delimitedSelector } from "../util/nodeSelectors";
import { values } from "lodash";

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-ruby/master/src/node-types.json \  
// | jq '[.[] | select(.type == "_expression") | .subtypes[].type]'
const EXPRESSION_TYPES = [
  "_arg",
  "assignment",
  "binary",
  "break",
  "call",
  "next",
  "operator_assignment",
  "return",
  "unary",
  "yield",
];

function isExpression(node: SyntaxNode) {
  return EXPRESSION_TYPES.includes(node.type);
}

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-ruby/master/src/node-types.json \  
// | jq '[.[] | select(.type == "_statement" or .type == "_simple_statement") | .subtypes[].type]'
const STATEMENT_TYPES = [
  "_expression",
  "alias",
  "begin_block",
  "end_block",
  "if_modifier",
  "rescue_modifier",
  "undef",
  "unless_modifier",
  "until_modifier",
  "while_modifier",
];

const mapTypes = ["hash"];
const listTypes = ["array", "string_array", "symbol_array"];

const nodeMatchers: Partial<Record<ScopeType, NodeMatcherAlternative>> = {
    map: mapTypes,
    list: listTypes, 
    statement: STATEMENT_TYPES, 
    string: "string",
    ifStatement: "if",
    functionCall: "call",
    comment: "comment",
    namedFunction: "method",
    functionName: "method[name]",
    anonymousFunction: "lambda",
    regularExpression: "regex",
    condition: conditionMatcher("*[condition]"), 
    argumentOrParameter: argumentMatcher("lambda_parameters", "method_parameters", "block_parameters"),
    class: "class",
    className: "class[name]",
    collectionKey: trailingMatcher(
    [
      "pair[key]",
    ],
    [":"]
    ),
    value: trailingMatcher(
    [
      "pair[value]",
    ],
    [":"]
    ),
    collectionItem: argumentMatcher(...mapTypes, ...listTypes),
};
export default createPatternMatchers(nodeMatchers);

// TODO: Look into pairs within strings, eg. `take pair` "(hello)"
// TODO: currently hashes with "new syntax" eg {1: 2} don't function correctly, I think this is because
// the trailing matcher. 
// TODO %w(word1 word2) leaves trailing spaces when deleted/changed