import {
  argumentMatcher,
  conditionMatcher,
  createPatternMatchers,
  trailingMatcher,
} from "../util/nodeMatchers";
import { NodeMatcherAlternative, ScopeType } from "../typings/Types";

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-ruby/master/src/node-types.json \  
// | jq '[.[] | select(.type == "_statement" or .type == "_simple_statement") | .subtypes[].type]'
const STATEMENT_TYPES = [
  "_expression",
  "alias",
  "begin_block",
  "end_block",
  "if_modifier",
  "rescue_modifier",
  "undef",
  "unless_modifier",
  "until_modifier",
  "while_modifier",
];

const mapTypes = ["hash"];
const listTypes = ["array", "string_array", "symbol_array"];

const nodeMatchers: Partial<Record<ScopeType, NodeMatcherAlternative>> = {
    map: mapTypes,
    list: listTypes, 
    statement: STATEMENT_TYPES, 
    string: "string",
    ifStatement: "if",
    functionCall: "call",
    comment: "comment",
    namedFunction: "method",
    functionName: "method[name]",
    anonymousFunction: "lambda",
    regularExpression: "regex",
    condition: conditionMatcher("*[condition]"), 
    argumentOrParameter: argumentMatcher("lambda_parameters", "method_parameters", "block_parameters"),
    class: "class",
    className: "class[name]",
    collectionKey: trailingMatcher(
    [
      "pair[key]",
    ],
    [":"]
    ),
    value: trailingMatcher(
    [
      "pair[value]",
    ],
    [":"]
    ),
    collectionItem: argumentMatcher(...mapTypes, ...listTypes),
};
export default createPatternMatchers(nodeMatchers);

// TODO: Look into pairs within strings, eg. `take pair` "(hello)"
// TODO %w(word1 word2) leaves trailing spaces when deleted/changed
// block comments are edited in an odd way, if there is an =end within the string e.g.

// =begin
// words comment =end
// =end