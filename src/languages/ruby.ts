import {
  argumentMatcher,
  conditionMatcher,
  createPatternMatchers,
  trailingMatcher,
} from "../util/nodeMatchers";
import { NodeMatcherAlternative, ScopeType, SelectionWithEditor } from "../typings/Types";
import { SyntaxNode } from "web-tree-sitter";
import { getNodeRange } from "../util/nodeSelectors";

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-ruby/master/src/node-types.json \  
// | jq '[.[] | select(.type == "_statement" or .type == "_simple_statement") | .subtypes[].type]'
const STATEMENT_TYPES = [
  "_expression",
  "alias",
  "begin_block",
  "end_block",
  "if_modifier",
  "rescue_modifier",
  "undef",
  "unless_modifier",
  "until_modifier",
  "while_modifier",
];

const mapTypes = ["hash"];
const listTypes = ["array", "string_array", "symbol_array"];

const nodeMatchers: Partial<Record<ScopeType, NodeMatcherAlternative>> = {
    map: mapTypes,
    list: listTypes, 
    statement: STATEMENT_TYPES, 
    string: "string",
    ifStatement: "if",
    functionCall: "call",
    comment: "comment",
    namedFunction: "method",
    functionName: "method[name]",
    anonymousFunction: "lambda",
    regularExpression: "regex",
    condition: conditionMatcher("*[condition]"), 
    argumentOrParameter: argumentMatcher("lambda_parameters", "method_parameters", "block_parameters"),
    class: "class",
    className: "class[name]",
    collectionKey: trailingMatcher(
    [
      "pair[key]",
    ],
    [":"]
    ),
    value: trailingMatcher(
    [
      "pair[value]",
    ],
    [":"]
    ),
    collectionItem: argumentMatcher(...mapTypes, ...listTypes),
};
export const patternMatchers = createPatternMatchers(nodeMatchers);

export function stringTextFragmentExtractor(
  node: SyntaxNode,
  _selection: SelectionWithEditor
) {
  if (node.type === "string_content") {
    return getNodeRange(node);
  }

  return null;
}