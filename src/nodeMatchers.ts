import { SyntaxNode } from "tree-sitter";
import { Position, Range, Selection, TextEditor } from "vscode";
import { SelectionContext } from "./Types";

interface SelectionWithContext {
  selection: Selection;
  context: SelectionContext;
}

type NodeMatcher = (
  editor: TextEditor,
  node: SyntaxNode
) => SelectionWithContext | null;

function hasType(...typeNames: string[]): NodeMatcher {
  return (editor: TextEditor, node: SyntaxNode) =>
    typeNames.includes(node.type) ? simpleSelectionExtractor(node) : null;
}

function getNextNonDelimiterNode(
  startNode: SyntaxNode,
  isDelimiterNode: (node: SyntaxNode) => boolean
): SyntaxNode | null {
  var node = startNode.nextSibling;

  while (node != null) {
    if (!isDelimiterNode(node)) {
      return node;
    }

    node = node.nextSibling;
  }

  return node;
}

function getPreviousNonDelimiterNode(
  startNode: SyntaxNode,
  isDelimiterNode: (node: SyntaxNode) => boolean
): SyntaxNode | null {
  var node = startNode.previousSibling;

  while (node != null) {
    if (!isDelimiterNode(node)) {
      return node;
    }

    node = node.previousSibling;
  }

  return node;
}

function delimitedMatcher(
  nodeMatches: (node: SyntaxNode) => boolean,
  isDelimiterNode: (node: SyntaxNode) => boolean,
  defaultDelimiter: string
): NodeMatcher {
  return (editor: TextEditor, node: SyntaxNode) => {
    if (!nodeMatches(node)) {
      return null;
    }

    var containingListDelimiter: string | null = null;
    var leadingDelimiterRange: Range | null = null;
    var trailingDelimiterRange: Range | null = null;

    const nextNonDelimiterNode = getNextNonDelimiterNode(node, isDelimiterNode);
    const previousNonDelimiterNode = getPreviousNonDelimiterNode(
      node,
      isDelimiterNode
    );

    if (nextNonDelimiterNode != null) {
      trailingDelimiterRange = new Range(
        new Position(node.endPosition.row, node.endPosition.column),
        new Position(
          nextNonDelimiterNode.startPosition.row,
          nextNonDelimiterNode.startPosition.column
        )
      );

      containingListDelimiter = editor.document.getText(trailingDelimiterRange);
    }

    if (previousNonDelimiterNode != null) {
      leadingDelimiterRange = new Range(
        new Position(
          previousNonDelimiterNode.endPosition.row,
          previousNonDelimiterNode.endPosition.column
        ),
        new Position(node.startPosition.row, node.startPosition.column)
      );

      if (containingListDelimiter == null) {
        containingListDelimiter = editor.document.getText(
          leadingDelimiterRange
        );
      }
    }

    if (containingListDelimiter == null) {
      containingListDelimiter = defaultDelimiter;
    }

    return {
      ...simpleSelectionExtractor(node),
      context: {
        isInDelimitedList: true,
        containingListDelimiter,
        leadingDelimiterRange,
        trailingDelimiterRange,
      },
    };
  };
}

function simpleSelectionExtractor(node: SyntaxNode): SelectionWithContext {
  return {
    selection: new Selection(
      new Position(node.startPosition.row, node.startPosition.column),
      new Position(node.endPosition.row, node.endPosition.column)
    ),
    context: {},
  };
}

// TODO figure out how to properly use super types
// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-typescript/4c20b54771e4b390ee058af2930feb2cd55f2bf8/typescript/src/node-types.json \
//   | jq '.[] | select(.type == "primary_expression" or .type == "expression") | [.subtypes[].type]'
const EXPRESSION_TYPES = [
  "array",
  "arrow_function",
  "as_expression",
  "assignment_expression",
  "augmented_assignment_expression",
  "await_expression",
  "binary_expression",
  "call_expression",
  "class",
  "false",
  "function",
  "generator_function",
  "identifier",
  "import",
  "internal_module",
  "member_expression",
  "meta_property",
  "new_expression",
  "non_null_expression",
  "null",
  "number",
  "object",
  "parenthesized_expression",
  "primary_expression",
  "regex",
  "string",
  "subscript_expression",
  "super",
  "template_string",
  "ternary_expression",
  "this",
  "true",
  "type_assertion",
  "unary_expression",
  "undefined",
  "update_expression",
  "yield_expression",
];

function isExpression(node: SyntaxNode) {
  return EXPRESSION_TYPES.includes(node.type);
}

const nodeMatchers = {
  class: hasType("class_declaration"),
  arrowFunction: hasType("arrow_function"),
  dictionary: hasType("object"),
  pair: delimitedMatcher(
    (node) => node.type === "pair",
    (node) => node.type === "," || node.type === "}" || node.type === "{",
    ", "
  ),
  argumentOrParameter: delimitedMatcher(
    (node) =>
      (node.parent?.type === "arguments" &&
        (isExpression(node) || node.type === "spread_element")) ||
      node.type === "optional_parameter" ||
      node.type === "required_parameter",
    (node) => node.type === "," || node.type === "(" || node.type === ")",
    ", "
  ),
  namedFunction(editor: TextEditor, node: SyntaxNode) {
    // Simple case, eg
    // function foo() {}
    if (
      node.type === "function_declaration" ||
      node.type === ".method_definition"
    ) {
      return simpleSelectionExtractor(node);
    }

    // Class property defined as field definition with arrow
    // eg:
    // class Foo {
    //   bar = () => "hello";
    // }
    if (
      node.type === "public_field_definition" &&
      // @ts-ignore
      node.valueNode.type === "arrow_function"
    ) {
      return simpleSelectionExtractor(node);
    }

    // eg:
    // const foo = () => "hello"
    if (node.type === "lexical_declaration") {
      if (node.namedChildCount !== 1) {
        return null;
      }

      const child = node.firstNamedChild!;

      if (
        child.type === "variable_declarator" &&
        // @ts-ignore
        child.valueNode.type === "arrow_function"
      ) {
        return simpleSelectionExtractor(node);
      }
    }

    return null;
  },
  ifStatement: hasType("if_statement"),
};

export default nodeMatchers;
